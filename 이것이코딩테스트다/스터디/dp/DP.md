
### 🧠 DP 문제 풀이 4단계 사고 과정

#### 1단계: `dp[i]`가 무엇을 의미하는지 '한 문장'으로 정의하기 (가장 중요)
가장 먼저 할 일은 배열에 담길 **값의 정의**를 명확히 하는 것입니다. 여기서 대부분의 승패가 갈립니다.

* **Type A (엄격한 정의):** $i$번째를 **반드시 포함(선택)했을 때**의 최대값.
    * *장점:* 점화식이 직관적임.
    * *단점:* 마지막에 `max(dp)`를 따로 해줘야 함.
* **Type B (누적 정의):** $i$번째까지 **고려했을 때(선택 안 해도 됨)**의 최대값.
    * *장점:* `dp[n]`이 곧 정답임. "안 먹는 경우"(`dp[i-1]`)를 쉽게 끌고 올 수 있음.
    * *이번 문제의 정답:* Type B 방식을 사용해서 성공하셨습니다.

#### 2단계: "마지막 행동"을 기준으로 경우의 수 나누기
$i$번째 상태가 되기 직전에 내가 할 수 있는 **행동(Action)**이 무엇인지 나열합니다. 행동은 서로 겹치지 않게(상호 배타적) 나눠야 합니다.

* 이번 문제의 경우:
    1.  이번 거 안 먹음 (Skip)
    2.  이번 거 먹음 (퐁당 건너뛰고)
    3.  이번 거 먹음 (연속으로)

#### 3단계: 제약 조건(모호함)을 해결하는 전략 선택
여기서 아까 고민하셨던 **"이전 상태가 모호한데 어떡하지?"**를 해결해야 합니다. 두 가지 전략이 있습니다.

**전략 1: 과거로 점프하기 (Lookback Strategy) - [이번에 쓰신 방법]**
* **개념:** 바로 앞(`i-1`)의 상태가 꼬여 있다면, 그 앞(`i-1`)과는 거래하지 않습니다. 확실한 과거(`i-2` 혹은 `i-3`)에서 값을 가져옵니다.
* **특징:** `dp` 배열을 1차원으로 유지할 수 있어 깔끔합니다.
* **사고 방식:** "연속 3번 먹으면 안 된다고? 그럼 연속으로 먹을 때는 **내 앞앞($i-2$)을 강제로 비워버리고 $i-3$에서 가져오자.**"

**전략 2: 상태 차원 늘리기 (State Expansion Strategy)**
* **개념:** 모호함을 없애기 위해 정보를 더 저장합니다. `dp[i]` 대신 `dp[i][연속횟수]`를 만듭니다.
* **특징:** 점화식 세우기가 뇌를 덜 써도 됩니다(단순해짐). 코드는 약간 길어집니다.
* **예시:**
    * `dp[i][0]`: $i$ 안 먹음
    * `dp[i][1]`: $i$ 먹음 (1번째 연속) -> `dp[i-1][0]`에서만 올 수 있음
    * `dp[i][2]`: $i$ 먹음 (2번째 연속) -> `dp[i-1][1]`에서만 올 수 있음

#### 4단계: 초기값(Base Case) 및 인덱스 처리
* $i=1, 2, 3$ 처럼 점화식이 적용되지 않는 앞부분을 수동으로 채워줍니다.
* **Tip:** 이번에 하신 것처럼 `pad` 값(0)을 배열 앞부분에 넉넉히 넣어서 인덱스 에러(`Out of Index`)를 방지하는 것이 실전에서 매우 유용합니다.

---

### 💡 실전 요약 (Cheat Sheet)

문제를 풀다가 "어? 이전 상태를 모르는데?" 싶으면 딱 이 두 가지만 떠올리세요.

1.  **"더 멀리서 가져오자" (점프)**
    * 바로 앞이 불확실하면, 조건이 초기화되는 지점($i-2, i-3$)까지 거슬러 올라가서 식을 세운다.
2.  **"정보를 더 저장하자" (차원 추가)**
    * 도저히 점프가 안 되면, `dp[i][0]`, `dp[i][1]` 처럼 배열을 늘려서 상태를 꼬리표처럼 달아준다.

이번 문제는 1번 전략(점프)을 아주 잘 적용하신 케이스입니다. 다음에도 **"바로 앞이랑 연결하기 애매하면, 징검다리를 건너뛰자"**는 아이디어를 떠올리시면 됩니다!